/*
I approached the 4Sum problem by leveraging a recursive kSum function. 
Initially, I sorted the input array nums to simplify the search for combinations 
that sum up to target. The kSum function handles the recursive part where it 
recursively reduces the problem to finding (k-1) sums after fixing one element.

Starting with the base case k == 2, I used a two-pointer technique in the twoSum 
function to find pairs that sum up to the remaining target after fixing one element. 
For higher values of k, the function recursively calls itself to find combinations 
that satisfy the sum condition.

The solution avoids duplicates by checking and skipping identical elements in the 
recursive calls. Finally, the results are returned in a list of lists containing 
the unique quadruplets.

Time: n^3
Space: n
*/

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        return kSum(nums, target, 0, 4);
    }

    public List<List<Integer>> kSum(int[] nums, long target, int start, int k) {
        List<List<Integer>> res = new ArrayList<>();

        // If we have run out of numbers to add, return res.
        if (start == nums.length) {
            return res;
        }

        // There are k remaining values to add to the sum. The
        // average of these values is at least target / k.
        long average_value = target / k;

        // We cannot obtain a sum of target if the smallest value
        // in nums is greater than target / k or if the largest
        // value in nums is smaller than target / k.
        if (nums[start] > average_value || average_value > nums[nums.length - 1]) {
            return res;
        }

        if (k == 2) {
            return twoSum(nums, target, start);
        }

        for (int i = start; i < nums.length; ++i) {
            if (i == start || nums[i - 1] != nums[i]) {
                for (List<Integer> subset : kSum(
                        nums,
                        target - nums[i],
                        i + 1,
                        k - 1)) {
                    res.add(new ArrayList<>(Arrays.asList(nums[i])));
                    res.get(res.size() - 1).addAll(subset);
                }
            }
        }

        return res;
    }

    public List<List<Integer>> twoSum(int[] nums, long target, int start) {
        List<List<Integer>> res = new ArrayList<>();
        Set<Long> s = new HashSet<>();

        for (int i = start; i < nums.length; ++i) {
            if (res.isEmpty() || res.get(res.size() - 1).get(1) != nums[i]) {
                if (s.contains(target - nums[i])) {
                    res.add(Arrays.asList((int) target - nums[i], nums[i]));
                }
            }
            s.add((long) nums[i]);
        }

        return res;
    }
}